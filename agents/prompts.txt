async def astream_events(self, initial_state: AgentState, config: Dict[str, Any], version: str = "v2"):
    """Low-level event stream with cycle support"""
    print("🔧 Using fallback astream approach for reliable events")
    
    # Add recursion_limit
    enhanced_config = {**config}
    if 'recursion_limit' not in enhanced_config:
        enhanced_config['recursion_limit'] = 25
    
    workflow_ended = False
    
    async for step in self.app.astream(initial_state, config=enhanced_config):
        print(f"📦 Astream step: {list(step.keys())}")
        
        for node_name, node_state in step.items():
            if node_name == '__end__':
                print(f"🏁 Workflow end - final state keys: {list(node_state.keys()) if isinstance(node_state, dict) else 'Not a dict'}")
                workflow_ended = True
                yield {"type": "workflow_end", "name": node_name, "data": node_state}
            else:
                print(f"✅ Node completed: {node_name}")
                
                # Check if this is a cycle back to navigation
                if node_name == "router_agent":
                    sql_followup_new_question = node_state.get('sql_followup_but_new_question', False)
                    if sql_followup_new_question:
                        print(f"  🔄 Detected cycle: router → navigation_controller")
                        print(f"  ⏭️ Stream will continue to next node...")
                
                yield {"type": "node_end", "name": node_name, "data": node_state}
    
    if not workflow_ended:
        print("⚠️ Stream ended without __end__ - workflow may have been interrupted")
