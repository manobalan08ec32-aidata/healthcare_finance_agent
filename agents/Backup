def _build_sql_writer_prompt(self, context_output: str, state: Dict, current_question: str) -> str:
        """Build the SQL writer prompt (Call 2)
        
        Takes raw context from planner and generates SQL with pattern learning.
        """
        
        history_question_match = state.get('history_question_match', '')
        matched_sql = state.get('matched_sql', '')
        has_history = bool(matched_sql and history_question_match)
        
        # Build history section
        if has_history:
            history_section = f"""
HISTORICAL SQL FOR PATTERN LEARNING

PREVIOUS QUESTION: {history_question_match}

<historical_sql>
{matched_sql}
</historical_sql>

PURPOSE: History represents LEARNED DETAIL PREFERENCES. Enhance simple questions with historical detail patterns.
PRINCIPLE: If history shows breakdown + totals, provide that detail level even if user asks simple question.

PATTERN DETECTION:

DETECT PATTERN TYPE:
- Contains "GROUPING SETS" + "GROUPING(" function → GROUPING_SETS_TOTAL
- Contains "UNION ALL" + 'Total'/'OVERALL' literal → UNION_TOTAL
- Neither → SIMPLE

IF GROUPING_SETS_TOTAL detected, extract:
- breakdown_column: column inside GROUPING() function
- parent_dimension: the parent filter column
- total_label: label used (OVERALL_TOTAL, Total, etc.)
- order_position: total first (0) or last (1) in ORDER BY

IF UNION_TOTAL detected, extract:
- How the total row is constructed
- What literal is used for the total label

ENHANCEMENT DECISION:

ENHANCE = YES when ALL true:
✓ Pattern is GROUPING_SETS_TOTAL or UNION_TOTAL
✓ Same/similar metric (both ask for revenue, both ask for cost, etc.)
✓ Current question filters on PARENT dimension of history's breakdown
✓ User did NOT say "total only", "just sum", "single number", "aggregate only"

ENHANCE = NO when ANY true:
✗ Pattern is SIMPLE (nothing to inherit)
✗ Different metric type entirely
✗ User explicitly wants only aggregate total
✗ Current already has different explicit grouping

HISTORY_SQL_USED FLAG:

Set history_sql_used = TRUE when ANY of these apply:
✓ Pattern inherited (GROUPING_SETS_TOTAL or UNION_TOTAL applied)
✓ History question is similar AND you learned/referenced:
  - Column selections or naming conventions
  - Filter logic or WHERE clause patterns
  - Calculation approach (CASE WHEN structure, formulas)
  - SQL structure (CTE, subquery patterns)
✓ History provided trusted reference that influenced your SQL generation

Set history_sql_used = FALSE ONLY when:
✗ No history SQL available
✗ History is completely irrelevant (different metric, different table, unrelated question)

NOTE: Even if ENHANCE = NO (no GROUPING_SETS/UNION pattern), set history_sql_used = TRUE if history influenced column choices, calculations, or structure.
"""
        else:
            history_section = """
HISTORICAL SQL:
No historical SQL available. Generate fresh SQL based on context.
Set pattern_detected = NONE and history_sql_used = false
"""
        state['sql_history_section'] = history_section

        prompt = f"""BUSINESS CONTEXT: You are a Databricks SQL code generator for DANA (Data Analytics Assistant), an internal enterprise business intelligence system at Optum. Your role is to generate accurate SQL queries for authorized business reporting and analytics on de-identified aggregate healthcare metrics.

TASK: Generate production-ready Databricks SQL based on the validated query plan and historical pattern learning.

CURRENT QUESTION: {current_question}

PLANNED CONTEXT:
{context_output}
{history_section}

SQL GENERATION RULES

PRIORITY 0: MANDATORY REQUIREMENTS (violation = query failure)

M1. MANDATORY FILTERS - Filters marked [MANDATORY] MUST be in WHERE clause, NEVER omit
M2. CASE-INSENSITIVE - Use UPPER() for all string comparisons
M3. SAFE DIVISION - Always use NULLIF(denominator, 0)
M4. NUMERIC FORMATTING - Amounts: ROUND(x, 0), Percentages: ROUND(x, 3)
M5. ONE COLUMN PER FILTER - Apply filter to single column, no OR across multiple columns

PRIORITY 1: METRIC TYPE HANDLING

- Pivot metric_type via CASE WHEN, never GROUP BY metric_type for calculations
- Pattern: SUM(CASE WHEN metric_type = 'X' THEN amt ELSE 0 END) AS x_value
- Calculations happen across columns in same row, not across rows

PRIORITY 2: COMPONENT DISPLAY

- Always show source components alongside calculated metrics
- Pattern: component_1, component_2, component_1 / NULLIF(component_2, 0) AS derived_metric

PRIORITY 3: QUERY PATTERNS

TIME COMPARISON (Always side-by-side columns, NEVER GROUP BY time period):
- Each period as column: SUM(CASE WHEN period = X THEN amt ELSE 0 END) AS period_x
- Include variance: period_2 - period_1 AS variance
- Include variance_pct: (variance / NULLIF(period_1, 0)) * 100
- Applies to: MoM, QoQ, YoY, any "X vs Y" time comparison

TOP N:
- ORDER BY metric DESC LIMIT N
- Include percentage of total when relevant

PERCENTAGE OF TOTAL:
- value, value * 100.0 / NULLIF((SELECT SUM FROM same_filters), 0) AS pct

BREAKDOWN:
- GROUP BY dimension columns, never GROUP BY metric_type for calculations

READING CONTEXT:

QUERY_TYPE = SINGLE_TABLE:
- Read QUERY_1 block, build single SELECT...FROM...WHERE...GROUP BY

QUERY_TYPE = MULTI_TABLE_JOIN:
- Read QUERY_1 and QUERY_2, use JOIN clause, build single SQL

QUERY_TYPE = MULTI_TABLE_SEPARATE:
- Generate SEPARATE SQL for each QUERY_N block
- Output in <multiple_sql> format

BUILDING SQL FROM CONTEXT:

1. SELECT: Use expressions from context exactly as provided
2. FROM: Use TABLE with alias from context
3. WHERE: Apply all FILTERS (UPPER() already applied for strings)
4. GROUP BY: Use from context (skip if "none")
5. ORDER BY: Use from context (skip if "none")
6. LIMIT: Use from context (skip if "none")

APPLY HISTORY PATTERN (if ENHANCE = YES):

IF GROUPING_SETS_TOTAL:
- Use GROUPING SETS clause with (parent, breakdown) and (parent)
- CASE WHEN GROUPING(col) = 1 THEN 'OVERALL_TOTAL' ELSE col END
- ORDER BY with total positioning

IF UNION_TOTAL:
- Detail query UNION ALL total query with 'OVERALL_TOTAL' literal
- ORDER BY with total positioning

IF ENHANCE = NO:
Generate SQL based on context INTENT:
- simple_aggregate → Aggregate only, no dimension GROUP BY
- breakdown → GROUP BY dimension columns
- comparison → Side-by-side CASE WHEN for periods
- top_n → ORDER BY DESC LIMIT N
- trend → GROUP BY time, ORDER BY time

OUTPUT FORMAT

FOR SINGLE_TABLE and MULTI_TABLE_JOIN:

<pattern_analysis>
pattern_detected: [GROUPING_SETS_TOTAL | UNION_TOTAL | SIMPLE | NONE]
breakdown_column: [column or null]
parent_dimension: [column or null]
enhance_decision: [YES | NO]
enhance_reason: [brief explanation]
</pattern_analysis>

<sql>
[Complete Databricks SQL]
</sql>

<sql_story>
[2-3 sentences explaining the query in business terms]
</sql_story>

<history_sql_used>[true | false]</history_sql_used>

FOR MULTI_TABLE_SEPARATE:

<pattern_analysis>
pattern_detected: NONE
enhance_decision: NO
enhance_reason: Multiple separate queries - history pattern not applicable
</pattern_analysis>

<multiple_sql>
<query1_title>[From QUERY_1 ANSWERS field - max 8 words]</query1_title>
<query1>
[SQL for QUERY_1]
</query1>
<query2_title>[From QUERY_2 ANSWERS field - max 8 words]</query2_title>
<query2>
[SQL for QUERY_2]
</query2>
</multiple_sql>

<sql_story>
[Explain that question required data from multiple tables without join relationship. Describe what each query returns.]
</sql_story>

<history_sql_used>false</history_sql_used>
"""
        return prompt
