# FILTER OUT common categorical values (case-insensitive), pass only meaningful values
            common_categorical_values = {'pbm','pbm retail', 'hdp', 'home delivery', 'mail', 'specialty','sp','claim fee','claim cost','admin fee','claimfee','claimcost','adminfee','8+4','9+3','2+10','5+7','optum','retail'}
            print("Current Timestamp before filter value call", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            # Filter out common categorical values
            meaningful_filter_values = []
            if filter_values:
                filter_values_lower = [str(val).lower().strip() for val in filter_values]
                meaningful_filter_values = [
                    filter_values[i] for i, val in enumerate(filter_values_lower) 
                    if val not in common_categorical_values
                ]
                
                if meaningful_filter_values:
                    print(f"ðŸ” Filtered filter values (removed categories): {meaningful_filter_values}")
                else:
                    print(f"â­ï¸ Skipping metadata search - all filter values are common categories: {filter_values}")
            
            metadata_search_task = None
            if meaningful_filter_values:
                print(f"ðŸ” Searching column index for filter values: {meaningful_filter_values}")
                # NEW: Use search_column_values instead of search_metadata_sql
                # Get column_index from state (loaded once in chat.py session initialization)
                column_index = state.get('column_index')
                if column_index:
                    # Call async function directly (already in async context)
                    metadata_search_task = self.db_client.search_column_values(
                        meaningful_filter_values,
                        column_index,
                        max_columns=7,
                        max_values_per_column=5
                    )
                else:
                    print("âš ï¸ Column index not available in state, skipping filter search")
            
            # 3. Execute metadata search if it was initiated
            print('metadata_search_task:',metadata_search_task)
            if metadata_search_task:
                try:
                    filter_metadata_results = await metadata_search_task
                    print(f"ðŸ“Š Found {len(filter_metadata_results)} filter metadata matches")
                    # Store in state for persistence
                    state['filter_metadata_results'] = filter_metadata_results
                except Exception as e:
                    print(f"âš ï¸ Filter metadata search failed: {e}")
                    filter_metadata_results = []
                    state['filter_metadata_results'] = []
            

async def search_column_values(
        self,
        search_terms: List[str],
        column_index: Dict[str, Any],
        max_columns: int = 7,
        max_values_per_column: int = 5
    ) -> List[str]:
        """
        Search for values across columns with tiered matching.
        
        Priority Order:
            Tier 1: Exact match (full term matches value exactly)
            Tier 2: Prefix match (value starts with term)
            Tier 3: Contains match (term found within value)
        
        Rules:
            - If exact match found, ignore partial matches for that term
            - Search full phrase first, then individual words
            - Return only matched values
        
        Args:
            search_terms: List of values to search (e.g., ["covid vaccine", "ozempic"])
            column_index: Loaded index dictionary from load_column_index_from_volume()
            max_columns: Maximum columns to return (default 7)
            max_values_per_column: Maximum matched values per column (default 5)
            
        Returns:
            List of formatted strings: ["column_name - value1, value2", ...]
        """
        
        if not search_terms:
            return []
        
        columns_data = column_index.get("columns", {})
        
        if not columns_data:
            print("âš ï¸ No columns data found in column index")
            return []
        
        # Track results per column
        # Structure: {column_name: {"tier": int, "values": set()}}
        column_matches = {}
        
        # Track which terms found exact matches (to skip partial for those)
        terms_with_exact_match = set()
        
        # Normalize search terms
        normalized_terms = []
        for term in search_terms:
            term_lower = term.strip().lower()
            if term_lower:
                normalized_terms.append(term_lower)
        
        # Build search list: full phrases + individual words
        search_list = []
        for term in normalized_terms:
            # Add full phrase first
            search_list.append({"term": term, "is_phrase": True})
            
            # Add individual words if phrase has multiple words
            words = term.split()
            if len(words) > 1:
                for word in words:
                    if len(word) > 2:  # Skip very short words
                        search_list.append({"term": word, "is_phrase": False})
        
        # PASS 1: Find all exact matches first
        for search_item in search_list:
            term = search_item["term"]
            
            for col_name, values in columns_data.items():
                if term in values:
                    terms_with_exact_match.add(term)
                    
                    if col_name not in column_matches:
                        column_matches[col_name] = {"tier": 1, "values": set()}
                    
                    # Only update if current tier is not better
                    if column_matches[col_name]["tier"] >= 1:
                        column_matches[col_name]["tier"] = 1
                        column_matches[col_name]["values"].add(term)
        
        # PASS 2: Prefix matches (only for terms without exact match)
        for search_item in search_list:
            term = search_item["term"]
            
            # Skip if this term already has exact match
            if term in terms_with_exact_match:
                continue
            
            for col_name, values in columns_data.items():
                for value in values:
                    if value.startswith(term) and value != term:
                        # Check if this term now has a prefix match
                        if col_name not in column_matches:
                            column_matches[col_name] = {"tier": 2, "values": set()}
                        
                        # Only add if column doesn't have exact matches
                        if column_matches[col_name]["tier"] >= 2:
                            column_matches[col_name]["tier"] = min(column_matches[col_name]["tier"], 2)
                            column_matches[col_name]["values"].add(value)
                        
                        break  # One prefix match per term per column is enough
        
        # PASS 3: Contains matches (only for terms without exact or prefix match)
        terms_with_prefix_or_exact = terms_with_exact_match.copy()
        
        # Find terms that got prefix matches
        for search_item in search_list:
            term = search_item["term"]
            for col_name, col_data in column_matches.items():
                if col_data["tier"] == 2:
                    for matched_val in col_data["values"]:
                        if matched_val.startswith(term):
                            terms_with_prefix_or_exact.add(term)
        
        for search_item in search_list:
            term = search_item["term"]
            
            # Skip if this term already has exact or prefix match
            if term in terms_with_prefix_or_exact:
                continue
            
            for col_name, values in columns_data.items():
                for value in values:
                    if term in value and not value.startswith(term) and value != term:
                        if col_name not in column_matches:
                            column_matches[col_name] = {"tier": 3, "values": set()}
                        
                        # Only add if column doesn't have better matches
                        if column_matches[col_name]["tier"] >= 3:
                            column_matches[col_name]["values"].add(value)
                        
                        break  # One contains match per term per column is enough
        
        # Sort columns by tier (best first)
        sorted_columns = sorted(
            column_matches.items(),
            key=lambda x: (x[1]["tier"], x[0])  # Sort by tier, then column name
        )
        
        # Format output
        results = []
        for col_name, col_data in sorted_columns[:max_columns]:
            matched_values = sorted(list(col_data["values"]))[:max_values_per_column]
            values_str = ", ".join(matched_values)
            results.append(f"{col_name} - {values_str}")
        
        print(f"âœ… Search complete: Found {len(results)} matching columns")
        return results
