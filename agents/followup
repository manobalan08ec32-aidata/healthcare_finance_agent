def render_historical_session_by_id(session_id: str):
    """Render all records for a historical session in chronological order.
    
    Args:
        session_id: The session ID to load all records for
    """
    try:
        print(f"üéØ USER ACTION: Loading historical session {session_id}")
        
        # Check if we already have this session cached to avoid refetching
        cache_key = f"session_records_{session_id}"
        if cache_key in st.session_state:
            print(f"üì¶ Using cached records for session {session_id}")
            records = st.session_state[cache_key]
        else:
            print(f"üîÑ Fetching records from database for session {session_id}")
            records = asyncio.run(_fetch_session_records(session_id))
            # Cache the records to avoid refetching
            st.session_state[cache_key] = records
        
        if not records:
            add_assistant_message(f"No records found for session: {session_id}", message_type="standard")
            return
        
        print(f"üìö Rendering {len(records)} records for session: {session_id}")
        
        # Process each record in chronological order (already ordered by insert_ts ASC)
        for i, record in enumerate(records):
            print(f"üîç Processing record {i+1}: type={type(record)}")
            
            if isinstance(record, dict):
                user_question = record.get('user_question', f'Question {i+1}')
                state_info_json = record.get('state_info', '')
                insert_ts = record.get('insert_ts', '')
            elif isinstance(record, str):
                # If record is a string, try to parse it as JSON
                try:
                    record_dict = json.loads(record)
                    user_question = record_dict.get('user_question', f'Question {i+1}')
                    state_info_json = record_dict.get('state_info', '')
                    insert_ts = record_dict.get('insert_ts', '')
                except json.JSONDecodeError:
                    print(f"‚ö†Ô∏è Could not parse record as JSON: {record[:100]}...")
                    continue
            else:
                print(f"‚ö†Ô∏è Skipping unexpected record type {type(record)}: {record}")
                continue
            
            print(f"  Processing record {i+1}: {user_question[:50]}... ({insert_ts})")
            
            # Add user message
            st.session_state.messages.append({
                "role": "user",
                "content": user_question,
                "message_type": "historical",
                "timestamp": insert_ts,
                "historical": True  # Mark as historical message
            })
            
            # Handle the assistant response
            if state_info_json and state_info_json.strip():
                try:
                    # Clean up the JSON string - handle different storage formats
                    cleaned_json = state_info_json.strip()
                    
                    print(f"    üîç Raw JSON first 100 chars: {cleaned_json[:100]}...")
                    
                    # Case 1: Triple quoted strings ("""{"json"}""")
                    if cleaned_json.startswith('"""') and cleaned_json.endswith('"""'):
                        cleaned_json = cleaned_json[3:-3]
                        print("    üîÑ Removed triple quotes")
                    
                    # Case 2: Double quoted JSON strings ("{\"key\":\"value\"}")
                    elif cleaned_json.startswith('"') and cleaned_json.endswith('"'):
                        # This is a JSON string stored as a quoted string
                        try:
                            # First parse: removes outer quotes and unescapes \" to ", \\n to actual \n
                            intermediate = json.loads(cleaned_json)
                            print("    üîÑ First parse: extracted JSON string")
                            
                            # If intermediate is a string, we need to clean it before parsing as JSON
                            if isinstance(intermediate, str):
                                # The intermediate string contains JSON-like text but may have unescaped quotes
                                # Strategy: Try multiple approaches in order
                                import re
                                import ast
                                
                                # Approach 1: Try parsing as-is (might work for simple cases)
                                try:
                                    cleaned_json = json.loads(intermediate)
                                    print("    ‚úÖ Second parse succeeded as-is")
                                except json.JSONDecodeError as e1:
                                    print(f"    üîÑ Direct parse failed: {e1}")
                                    
                                    # Approach 2: Use ast.literal_eval after converting to Python dict syntax
                                    try:
                                        # Replace JSON booleans with Python booleans
                                        intermediate_py = intermediate.replace('true', 'True').replace('false', 'False').replace('null', 'None')
                                        cleaned_json = ast.literal_eval(intermediate_py)
                                        print("    ‚úÖ Second parse succeeded with ast.literal_eval")
                                    except (ValueError, SyntaxError) as e2:
                                        print(f"    üîÑ ast.literal_eval failed: {e2}")
                                        
                                        # Approach 3: Properly escape newlines and control characters for JSON
                                        try:
                                            # Replace actual newline/tab/carriage return with JSON escape sequences
                                            intermediate_clean = intermediate.replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
                                            # Also handle any other control characters
                                            intermediate_clean = re.sub(r'[\x00-\x08\x0b-\x1f]', lambda m: f'\\u{ord(m.group()):04x}', intermediate_clean)
                                            cleaned_json = json.loads(intermediate_clean)
                                            print("    ‚úÖ Second parse succeeded after newline escape")
                                        except json.JSONDecodeError as e3:
                                            print(f"    ‚ùå All parsing attempts failed")
                                            error_pos = getattr(e3, 'pos', 0)
                                            print(f"    üìù Problematic area around char {error_pos}: '{intermediate[max(0, error_pos-30):error_pos+30]}'")
                                            # Create error result with partial data
                                            cleaned_json = {
                                                "error": f"JSON parse error: {str(e3)}",
                                                "title": user_question,
                                                "narrative": "Error parsing stored data - please contact support",
                                                "sql_query": intermediate[:500] if len(intermediate) > 500 else intermediate
                                            }
                            else:
                                # Already a dict after first parse
                                cleaned_json = intermediate
                                print("    ‚úÖ First parse returned dict directly")
                                
                        except json.JSONDecodeError as e:
                            print(f"    ‚ùå First parse failed: {e}")
                            cleaned_json = {
                                "error": f"JSON parse error: {str(e)}",
                                "title": user_question,
                                "narrative": "Error parsing stored data"
                            }
                    
                    print(f"    üîç Cleaned JSON preview: {str(cleaned_json)[:100]}...")
                    
                    # At this point, cleaned_json should be a dict (either parsed or error dict)
                    if isinstance(cleaned_json, dict):
                        sql_result = cleaned_json
                        print(f"    ‚úÖ Using parsed JSON object")
                    else:
                        print(f"    ‚ùå Unexpected type: {type(cleaned_json)}")
                        sql_result = {
                            "error": "Unexpected data type after parsing",
                            "title": user_question,
                            "narrative": "Error processing stored data"
                        }
                    
                    # Add assistant message for the SQL result
                    message = {
                        "role": "assistant",
                        "content": "",
                        "message_type": "sql_result",
                        "timestamp": insert_ts,
                        "sql_result": sql_result,
                        "rewritten_question": user_question,
                        "historical": True  # Mark as historical message
                    }
                    st.session_state.messages.append(message)
                    print(f"    ‚úÖ Added SQL result for record {i+1}")
                    
                except json.JSONDecodeError as e:
                    print(f"    ‚ùå JSON parse error for record {i+1}: {e}")
                    print(f"    üîç Raw JSON: {state_info_json[:200]}...")
                    add_assistant_message(f"Data parsing error for: {user_question}", message_type="standard")
                    
            else:
                # No state_info available
                add_assistant_message(f"Historical response (limited data): {user_question}", message_type="standard")
                print(f"    ‚ö†Ô∏è No state_info for record {i+1}")
        
        print(f"‚úÖ Completed rendering session {session_id} with {len(records)} records")
        
    except Exception as e:
        st.error(f"Error loading historical session {session_id}: {e}")
        print(f"‚ùå Error rendering historical session {session_id}: {e}")
        add_assistant_message(f"Error loading session: {session_id}", message_type="standard")
