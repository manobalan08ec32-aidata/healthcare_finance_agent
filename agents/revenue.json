vector results [{'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': ' The billed_amount field represents the revenue amount or billing amount charged to clients. This is the primary financial metric for revenue analysis, billing summaries, financial calculations, total revenue reporting, and understanding amounts invoiced to clients. Use billed_amount for all monetary calculations, revenue trends, and financial performance analysis.Revenue and activity categorization fields include rev_src_type which classifies revenue sources as claim fee, claim cost, or admin fee for understanding revenue composition and type-based analysis', 'llm_context': '-**billed_amount**: Represents the total billed amount, also referred to as billing revenue.\n                        -If the user asks for total billed amount, do not apply a GROUP BY on the rev_src_type column.\n                        -If the user asks for claim billed amount, filter using rev_src_type = "CLAIM COST"\n                        -If the user refers to claim fee or activity fee, treat it as a fee-based request and apply the appropriate rev_src_type filter.\n- **rev_src_type**: Categorizes the revenue source.. Distinct Values include "CLAIM FEE", "CLAIM COST", and "ACTIVITY FEE". when the user asks for specific fee, use this column else aggregate all amount and no group by needed.\n\n', 'score': 1.0}, {'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': ' Product identification fields include oracle_prod_code containing Oracle system product codes like PROD35 and PROD57, paired with orcl_prod_desc providing detailed product descriptions such as E-Prescribing Admin Fee, PMPM-VCS, and Prior Auth Specialty. These fields enable product-level analysis, product mix reporting, revenue by product calculations, and understanding which services or products are being billed to clients.The actvty_category_cd field contains activity category codes like 02EPRES and 01PCMS for operational classification and activity-based segmentation. Use these fields to analyze revenue by source type, understand billing composition, and perform activity-based reporting and analysis', 'llm_context': '- **oracle_prod_code**:This is not drug related product code.This is billing services from the Oracle system. Examples include PROD35, PROD57. Use for product-level categorization and analysis.\n- **orcl_prod_desc**: Oracle product description providing detailed product names. Examples include "E-Prescribing Admin Fee", "PMPM-VCS", "Prior Auth. Specialty". Use for product identification and reporting.\n- **actvty_category_cd**: Activity category code for operational classification. Examples include 02EPRES, 01PCMS. Use for activity-based analysis and categorization.\n\n', 'score': 0.5}, {'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': 'Line of business with line_of_business (LOB) codes (E&I FI, E&I ASO, C&S, PDP, MAPD, E&I UMR, External) and line_of_business_desc long names (Employer & Individual – United Medical Resources, Medicare Advantage Prescription Drug, Prescription Drug Plan, Others, Community & State, Employer & Individual – Fully Insured, Employer & Individual – Administrative Services Only, External); distinct from client_type', 'llm_context': '- **line_of_business_name**: Contains line of business (LOB) identifier such as External,C&S,E&I FI,E&I ASO,PDP,MAPD,E&I UMR and when the user asks plainly external then use this column for filtering and is distinct from client type. [Distinct Values: E&I-FI,E&I-ASO,C&S,PDP,MAPD,E&I-UMR,External]\n', 'score': 0.3333333333333333}, {'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': 'Billing entity fields identify who is performing the billing with blng_entty_cd containing billing entity codes such as ORXUHC0036XX and ORXUHC0005XX, and blng_entty_name providing entity names like UHC INSURANCE COMPANY and UHCACIS FULLY INSURED. This helps to accurately report whihc billing entity generates the invoices.\n', 'llm_context': '- **blng_entty_cd**: Billing entity code identifier. Examples include ORXUHC0036XX, ORXUHC0005XX. Use to identify which entity is performing the billing.\n- **blng_entty_name**: Billing entity name providing descriptive entity information. Examples include "UHC INSURANCE COMPANY", "UHCACIS FULLY INSURED". Use for entity-level reporting and analysis.\n\n', 'score': 0.25}, {'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': 'claim_nbr (unique claim id, not a count), claim_seq_nbr (sequence within claim), claim_status_code with P=Paid and X=Reversed for net activity; use P and X for utilization and financial derivations', 'llm_context': '- **claim_nbr**: Contains unique claim numbers used to identify individual claims in the dataset. should not be used for any aggregation.\n- **claim_seq_nbr**: Sequence of transactions within the same claim_nbr (e.g., original, reversal). Not used for aggregations.\n- **claim_status_code**: Processing status of the claim. For utilization/financial metrics use P (Paid)and X (Reveresed). Paid and reversed together reflect net activity.Always Include P,X for derivation. [Values: P, X]', 'score': 0.2}, {'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': 'Invoice identification and timing fields include inv_nbr which is the unique invoice number identifier for each billing record, invoice_date representing when the invoice was generated and issued to the client, and invoice_gl_date which is the general ledger posting date used for financial period reporting. These fields are essential for invoice lookup, tracking invoice timing, aging analysis, and reconciling invoices with the general ledger system.', 'llm_context': '- **inv_nbr**: The invoice number is a unique identifier used to distinguish individual invoices within the billing system.\n                When a user requests an invoice number without specifying an invoice date, do not prompt for or infer a time period. The system should return the invoice number directly without requesting additional temporal context. . \n- **invoice_date**:(YYYY-MM-DD) format. Date when the invoice was generated and issued to the client. \n                    Use for invoice timing and aging analysis.when the user mentions invoice date then use this column.\n- **invoice_gl_date**:(YYYY-MM-DD) format. General ledger posting date for the invoice. Use for financial period reporting and GL reconciliation. May differ from invoice_date.\n\n', 'score': 0.16666666666666666}, {'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': 'General ledger string components are 3-digit codes used for financial accounting and reporting in the GL system. Fields include fqa_cmpny_cd for company segmentation, fqa_geo_cd for geographic financial tracking, fqa_aflt_cd for affiliate-level accounting, fqa_lob_cd for line of business P&L reporting, fqa_acnt_cd for account mapping, fqa_dept_cd for departmental cost allocation, fqa_prod_cd for product-level financial tracking, and fqa_sub_acnt_cd for sub-account detail. These GL string components enable financial reporting, cost allocation, departmental budgeting, geographic P&L analysis, and reconciliation between billing data and the general ledger system.\n', 'llm_context': 'The following fields comprise the GL string used for financial accounting and reporting:\n- **fqa_cmpny_cd**: 3-digit company code component of the GL string. Use for company-level financial segmentation.\n- **fqa_geo_cd**: 3-digit geography code component of the GL string. Use for geographic financial segmentation and reporting.\n- **fqa_aflt_cd**: 3-digit affiliate code component of the GL string. Use for affiliate-level financial tracking.\n- **fqa_lob_cd**: 3-digit line of business code component of the GL string. Use for LOB financial segmentation and P&L reporting.\n- **fqa_acnt_cd**: 3-digit account code component of the GL string. Use for account-level GL mapping.This account is not related to carrier , account,employer_group_id.\n- **fqa_dept_cd**: 3-digit department code component of the GL string. Use for departmental cost allocation and reporting.\n- **fqa_prod_cd**: 3-digit product code component of the GL string. Use for product-level financial tracking in GL.This is not oracle product code.\n- **fqa_sub_acnt_cd**: 3-digit sub-account code component of the GL string. Use for detailed sub-account level GL analysis.This is not related to carrier account group.\n\n', 'score': 0.14285714285714285}, {'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': 'Drug attributes including drug_name, therapy_class_name (e.g., Oncology, GLP-1 Receptor Agonists, SGLT-2 Inhibitors & Combos, GLP-1 Anti-Obesity Agents), brand_vs_generic_ind (Brand vs Generic for GDR), gpi_no standardized classification, DRUG_MANUFCTR_NM manufacturer; supports molecule/class market share, brand vs generic mix, and GDR (derived, not stored)', 'llm_context': '- **drug_name**: Name of the dispensed drug; use for molecule-level trends and financials.\n- **therapy_class_name**: Therapeutic class of the drug. Choose class or specific drug based on the question. sample therapy class names are Oncology,GLP-1 Receptor Agonists,SGLT-2 Inhibitors & Combos,GLP-1 Anti-Obesity Agents.if the user is asking generically GLP-1 then use like operator to get all the GLP-1 related information\n- **brand_vs_generic_ind**: Product type indicator. Drives brand/generic mix and Generic Dispense Rate and also use it filter clause in case of brand vs generic calculation using distinct values [Values: Brand, Generic]\n- **gpi_no**: GPI code.\n-**DRUG_MANUFCTR_NM**:Drug manufacturer; supports brand/manufacturer market-share views\n\n', 'score': 0.125}, {'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': ' client_id (unique id), client_name (description name) used for client level reporting for billing data', 'llm_context': '- **client_id**: This contain unique 5-6 digit client code.Sample values [ABCD,WXYZ,57939]\n- **client_description**: This contains client description. Return alongside client_id for user-facing reports .Sample values ["MDOVA OVATIONS MAPD/MA ONLY/RDS","PDIND PDP INDIVIDUAL"]\n\n', 'score': 0.1111111111111111}, {'table_name': 'prd_optumrx_orxfdmprdsa.rag.claim_billing', 'col_embedding_content': 'Carrier–Account–Group hierarchy: carrier_id (carrier), account_id (account), group_id (group/subgroup); CAG is a calculated concatenation of carrier_id, account_id, and group_id for CAG-level reporting', 'llm_context': '- **carrier_id**: Insurance carrier identifier in the billing system. \n- **account_id**: Account identifier used for account-level grouping and analysis within the billing hierarchy.\n- **group_id**: Group identifier for organizing and aggregating accounts into logical groupings.\n-**CAG**: calculated column .concatenate carrier id , account id and group id to derive CAG\n\n', 'score': 0.1}]

async def get_metadata(self, state: Dict, selected_dataset: list) -> Dict:
        """Extract metadata with mandatory embeddings from single JSON file"""
        try:
            current_question = state.get('rewritten_question', state.get('current_question', ''))
            embedding_idx = "prd_optumrx_orxfdmprdsa.rag.column_embeddings_pbm_idx"
            
            tables_list = selected_dataset if isinstance(selected_dataset, list) else [selected_dataset] if selected_dataset else []
            print(f'📊 Tables selected: {tables_list}')
            
            # ===== STEP 1: Load Mandatory Embeddings (Cached - Fast!) =====
            mandatory_contexts = get_mandatory_embeddings_for_tables(tables_list)
            print('mandatory context',mandatory_contexts)
            # ===== STEP 2: Get Vector Search Results =====
            vector_results = await self.db_client.sp_vector_search_columns(
                query_text=current_question,
                tables_list=tables_list,
                num_results_per_table=10,
                index_name=embedding_idx
            )
            print('vector results',vector_results)
            # ===== STEP 3: Group Vector Results =====
            vector_contexts_by_table = {}
            for result in vector_results:
                table = result['table_name']
                if table not in vector_contexts_by_table:
                    vector_contexts_by_table[table] = []
                vector_contexts_by_table[table].append(result['llm_context'])
            
            # ===== STEP 4: Merge & Deduplicate =====
            merged_contexts_by_table = {}
            
            for table in tables_list:
                seen_columns = set()
                merged_contexts_by_table[table] = []
                
                # Add mandatory first
                if table in mandatory_contexts:
                    for ctx in mandatory_contexts[table]:
                        col_name = ctx.split('**')[1].split(':')[0].strip() if ctx.startswith('**') and ':' in ctx else None
                        if col_name:
                            seen_columns.add(col_name)
                        merged_contexts_by_table[table].append(ctx)
                
                # Add vector results (skip duplicates)
                if table in vector_contexts_by_table:
                    for ctx in vector_contexts_by_table[table]:
                        col_name = ctx.split('**')[1].split(':')[0].strip() if ctx.startswith('**') and ':' in ctx else None
                        if col_name and col_name not in seen_columns:
                            merged_contexts_by_table[table].append(ctx)
                            seen_columns.add(col_name)
            
            # ===== STEP 5: Build Metadata =====
            metadata = ""
            for table in tables_list:
                if table in merged_contexts_by_table and merged_contexts_by_table[table]:
                    metadata += f"\n## Table: {table}\n\n"
                    for ctx in merged_contexts_by_table[table]:
                        metadata += ctx + "\n"
                    metadata += "\n"
            print('metadata',metadata)
            return {
                'status': 'success',
                'metadata': metadata,
                'error': False
            }
            
        except Exception as e:
            print(f"❌ Metadata extraction failed: {str(e)}")
            import traceback
            traceback.print_exc()
            
            return {
                'status': 'error',
                'metadata': '',
                'error': True,
                'error_message': f"Metadata extraction failed: {str(e)}"
            }
