âœ… Converted DataFrame to list: 5 rows

ðŸ“Š Results breakdown:
   Tier 1 (EXACT): 2 columns
   Tier 2 (STARTS-WITH): 1 columns
   Tier 3 (CONTAINS): 2 columns

âœ… TIER 1 (EXACT): Found 2 matches - Returning only these

ðŸ“‹ Formatted 2 results for EXACT matches

ðŸŽ¯ FINAL RESULTS:
Column: client_name (Tier: 1, Type: EXACT)
  - Values: EXTERNAL, TEXAS ERS-EXTERNAL
Column: line_of_business (Tier: 1, Type: EXACT)
  - Values: External

"""
Standalone synchronous version for direct Databricks testing
No async, no self, uses spark.sql() directly
"""
from typing import List

def search_metadata_sql(filter_list: List[str]) -> List[str]:
    """
    Search metadata with cascading priority (returns ONLY highest priority matches):
    1. EXACT MATCH - Full term matches exactly
    2. STARTS-WITH MATCH - Value starts with the full term
    3. CONTAINS MATCH - Individual words found anywhere
    
    OPTIMIZED: Single database query, Python-based filtering
    """
    try:
        if not filter_list:
            return []
        
        print(f"ðŸ” Starting single-query cascading search for filters: {filter_list}")
        
        # Build all match conditions for a SINGLE query
        exact_conditions = []
        starts_conditions = []
        contains_conditions = []
        
        for term in filter_list:
            term_clean = term.strip().lower()
            escaped_exact = term_clean.replace("'", "\\'")
            escaped_regex = term_clean.replace('\\', '\\\\').replace('(', '\\(').replace(')', '\\)').replace('[', '\\[').replace(']', '\\]')
            
            # TIER 1: Exact match condition
            exact_conditions.append(f"lower(trim(exploded_value)) = '{escaped_exact}'")
            
            # TIER 2: Starts-with condition
            starts_conditions.append(f"lower(trim(exploded_value)) RLIKE '^{escaped_regex}\\\\b'")
            
            # TIER 3: Individual words
            words = term_clean.split()
            for word in words:
                if len(word) > 2:
                    escaped_word = word.replace('\\', '\\\\').replace('(', '\\(').replace(')', '\\)').replace('[', '\\[').replace(']', '\\]')
                    contains_conditions.append(f"lower(trim(exploded_value)) RLIKE '(?i)\\\\b{escaped_word}'")
        
        # Build tier scoring logic
        exact_clause = ' OR '.join(exact_conditions)
        starts_clause = ' OR '.join(starts_conditions)
        contains_clause = ' OR '.join(contains_conditions)
        
        # Combine all conditions for WHERE clause
        all_conditions = f"({exact_clause}) OR ({starts_clause}) OR ({contains_clause})"
        
        # Tier assignment: highest tier wins for each row
        tier_assignment = f"""
            CASE 
                WHEN {exact_clause} THEN 1
                WHEN {starts_clause} THEN 2
                ELSE 3
            END
        """
        
        query = f"""
        WITH matched_data AS (
            SELECT
                column_name,
                trim(exploded_value) AS individual_value,
                {tier_assignment} AS match_tier
            FROM prd_optumrx_orxfdmprdsa.rag.distinct_values_metadata1
            LATERAL VIEW explode(split(distinct_values, ',')) AS exploded_value
            WHERE {all_conditions}
        ),
        scored_aggregated AS (
            SELECT
                column_name,
                collect_list(individual_value) AS all_matched_values,
                MIN(match_tier) AS best_tier  -- Get the best (lowest) tier for each column
            FROM matched_data
            GROUP BY column_name
        )
        SELECT
            column_name,
            concat_ws(', ', slice(all_matched_values, 1, 5)) AS matched_values,
            best_tier
        FROM scored_aggregated
        ORDER BY best_tier ASC, column_name
        """
        
        print(f"ðŸ“Š Single Query (All Tiers):")
        print(query)
        print("\n")
        
        # Execute using spark.sql()
        result_df = spark.sql(query)
        print('results_data_filter:', result_df)
        
        # Convert DataFrame to list of dictionaries
        result_list = [row.asDict() for row in result_df.collect()]
        print(f"âœ… Converted DataFrame to list: {len(result_list)} rows")
        
        if not result_list:
            print(f"âŒ No matches found")
            return []
        
        # Python filtering: Return ONLY the highest priority tier
        return filter_by_priority(result_list)
        
    except Exception as e:
        print(f"âŒ Error in search_metadata_sql: {str(e)}")
        import traceback
        traceback.print_exc()
        return []


def filter_by_priority(result_data: list) -> List[str]:
    """
    Filter results to return ONLY the highest priority tier found
    Tier 1 (Exact) > Tier 2 (Starts-With) > Tier 3 (Contains)
    """
    if not result_data:
        return []
    
    # Group results by tier
    tier_1_results = []
    tier_2_results = []
    tier_3_results = []
    
    for row in result_data:
        tier = int(row.get('best_tier', 3))  # Convert to int for proper comparison
        column_name = row.get('column_name', '')
        matched_values = row.get('matched_values', '')
        
        result_entry = {
            'column_name': column_name,
            'matched_values': matched_values,
            'tier': tier
        }
        
        if tier == 1:
            tier_1_results.append(result_entry)
        elif tier == 2:
            tier_2_results.append(result_entry)
        else:
            tier_3_results.append(result_entry)
    
    print(f"\nðŸ“Š Results breakdown:")
    print(f"   Tier 1 (EXACT): {len(tier_1_results)} columns")
    print(f"   Tier 2 (STARTS-WITH): {len(tier_2_results)} columns")
    print(f"   Tier 3 (CONTAINS): {len(tier_3_results)} columns")
    
    # Return ONLY highest priority tier with results
    if tier_1_results:
        print(f"\nâœ… TIER 1 (EXACT): Found {len(tier_1_results)} matches - Returning only these")
        return format_results(tier_1_results[:7], "EXACT")  # Limit to 7
    
    if tier_2_results:
        print(f"\nâœ… TIER 2 (STARTS-WITH): Found {len(tier_2_results)} matches - Returning only these")
        return format_results(tier_2_results[:7], "STARTS-WITH")
    
    if tier_3_results:
        print(f"\nâœ… TIER 3 (CONTAINS): Found {len(tier_3_results)} matches - Returning these")
        return format_results(tier_3_results[:7], "CONTAINS")
    
    print(f"\nâŒ No results after filtering")
    return []


def format_results(result_data: list, match_type: str) -> List[str]:
    """
    Format the query results into a list of strings
    """
    concatenated_results = []
    
    for row in result_data:
        column_name = row.get('column_name', '')
        matched_values = row.get('matched_values', '')
        tier = row.get('tier', '')
        
        table_summary = f"Column: {column_name} (Tier: {tier}, Type: {match_type})\n  - Values: {matched_values}"
        concatenated_results.append(table_summary)
    
    print(f"\nðŸ“‹ Formatted {len(concatenated_results)} results for {match_type} matches")
    return concatenated_results


# ===========================================
# TEST USAGE IN DATABRICKS
# ===========================================

# Test 1: Single word filter
print("=" * 80)
print("TEST 1: Single word filter - 'External'")
print("=" * 80)
results1 = search_metadata_sql(['External'])
print("\nðŸŽ¯ FINAL RESULTS:")
for result in results1:
    print(result)

print("\n\n")

# Test 2: Multi-word filter
print("=" * 80)
print("TEST 2: Multi-word filter - 'covid vaccine'")
print("=" * 80)
results2 = search_metadata_sql(['covid vaccine'])
print("\nðŸŽ¯ FINAL RESULTS:")
for result in results2:
    print(result)

print("\n\n")

# Test 3: Multiple filters
print("=" * 80)
print("TEST 3: Multiple filters - ['External', 'diabetes']")
print("=" * 80)
results3 = search_metadata_sql(['External', 'diabetes'])
print("\nðŸŽ¯ FINAL RESULTS:")
for result in results3:
    print(result)


async def search_metadata_sql(self, filter_list: List[str]) -> List[str]:
    """
    Search metadata with cascading priority (returns ONLY highest priority matches):
    1. EXACT MATCH - Full term matches exactly
    2. STARTS-WITH MATCH - Value starts with the full term
    3. CONTAINS MATCH - Individual words found anywhere
    
    OPTIMIZED: Single database query, Python-based filtering
    """
    try:
        if not filter_list:
            return []
        
        print(f"ðŸ” Starting single-query cascading search for filters: {filter_list}")
        
        # Build all match conditions for a SINGLE query
        exact_conditions = []
        starts_conditions = []
        contains_conditions = []
        tier_score_cases = []
        
        for term in filter_list:
            term_clean = term.strip().lower()
            escaped_exact = term_clean.replace("'", "\\'")
            escaped_regex = term_clean.replace('\\', '\\\\').replace('(', '\\(').replace(')', '\\)').replace('[', '\\[').replace(']', '\\]')
            
            # TIER 1: Exact match condition
            exact_conditions.append(f"lower(trim(exploded_value)) = '{escaped_exact}'")
            
            # TIER 2: Starts-with condition
            starts_conditions.append(f"lower(trim(exploded_value)) RLIKE '^{escaped_regex}\\\\b'")
            
            # TIER 3: Individual words
            words = term_clean.split()
            for word in words:
                if len(word) > 2:
                    escaped_word = word.replace('\\', '\\\\').replace('(', '\\(').replace(')', '\\)').replace('[', '\\[').replace(']', '\\]')
                    contains_conditions.append(f"lower(trim(exploded_value)) RLIKE '(?i)\\\\b{escaped_word}'")
        
        # Build tier scoring logic
        exact_clause = ' OR '.join(exact_conditions)
        starts_clause = ' OR '.join(starts_conditions)
        contains_clause = ' OR '.join(contains_conditions)
        
        # Combine all conditions for WHERE clause
        all_conditions = f"({exact_clause}) OR ({starts_clause}) OR ({contains_clause})"
        
        # Tier assignment: highest tier wins for each row
        tier_assignment = f"""
            CASE 
                WHEN {exact_clause} THEN 1
                WHEN {starts_clause} THEN 2
                ELSE 3
            END
        """
        
        query = f"""
        WITH matched_data AS (
            SELECT
                column_name,
                trim(exploded_value) AS individual_value,
                {tier_assignment} AS match_tier
            FROM prd_optumrx_orxfdmprdsa.rag.distinct_values_metadata1
            LATERAL VIEW explode(split(distinct_values, ',')) AS exploded_value
            WHERE {all_conditions}
        ),
        scored_aggregated AS (
            SELECT
                column_name,
                collect_list(individual_value) AS all_matched_values,
                MIN(match_tier) AS best_tier  -- Get the best (lowest) tier for each column
            FROM matched_data
            GROUP BY column_name
        )
        SELECT
            column_name,
            concat_ws(', ', slice(all_matched_values, 1, 5)) AS matched_values,
            best_tier
        FROM scored_aggregated
        ORDER BY best_tier ASC, column_name
        """
        
        print(f"ðŸ“Š Single Query (All Tiers): {query}")
        
        # Execute ONCE
        result_data = await self.execute_sql_async_audit(query)
        print('results_data_filter', result_data)
        
        # Convert DataFrame to list if needed
        if hasattr(result_data, 'collect'):
            # It's a Spark DataFrame - convert to list of dicts
            result_list = [row.asDict() for row in result_data.collect()]
            print(f"âœ… Converted DataFrame to list: {len(result_list)} rows")
        elif isinstance(result_data, list):
            result_list = result_data
        else:
            print(f"âŒ Unexpected result type: {type(result_data)}")
            return []
        
        if not result_list:
            print(f"âŒ No matches found")
            return []
        
        # Python filtering: Return ONLY the highest priority tier
        return self._filter_by_priority(result_list)
        
    except Exception as e:
        print(f"âŒ Error in search_metadata_sql: {str(e)}")
        return []


def _filter_by_priority(self, result_data: list) -> List[str]:
    """
    Filter results to return ONLY the highest priority tier found
    Tier 1 (Exact) > Tier 2 (Starts-With) > Tier 3 (Contains)
    """
    if not result_data:
        return []
    
    # Group results by tier
    tier_1_results = []
    tier_2_results = []
    tier_3_results = []
    
    for row in result_data:
        tier = int(row.get('best_tier', 3))  # Convert to int for proper comparison
        column_name = row.get('column_name', '')
        matched_values = row.get('matched_values', '')
        
        result_entry = {
            'column_name': column_name,
            'matched_values': matched_values,
            'tier': tier
        }
        
        if tier == 1:
            tier_1_results.append(result_entry)
        elif tier == 2:
            tier_2_results.append(result_entry)
        else:
            tier_3_results.append(result_entry)
    
    # Return ONLY highest priority tier with results
    if tier_1_results:
        print(f"âœ… TIER 1 (EXACT): Found {len(tier_1_results)} matches - Returning only these")
        return self._format_results(tier_1_results[:7], "EXACT")  # Limit to 7
    
    if tier_2_results:
        print(f"âœ… TIER 2 (STARTS-WITH): Found {len(tier_2_results)} matches - Returning only these")
        return self._format_results(tier_2_results[:7], "STARTS-WITH")
    
    if tier_3_results:
        print(f"âœ… TIER 3 (CONTAINS): Found {len(tier_3_results)} matches - Returning these")
        return self._format_results(tier_3_results[:7], "CONTAINS")
    
    print(f"âŒ No results after filtering")
    return []


def _format_results(self, result_data: list, match_type: str) -> List[str]:
    """
    Format the query results into a list of strings
    """
    concatenated_results = []
    
    for row in result_data:
        column_name = row.get('column_name', '')
        matched_values = row.get('matched_values', '')
        tier = row.get('tier', '')
        
        table_summary = f"Column: {column_name} (Tier: {tier}, Type: {match_type})\n  - Values: {matched_values}"
        concatenated_results.append(table_summary)
    
    print(f"ðŸ“‹ Formatted {len(concatenated_results)} results for {match_type} matches")
    return concatenated_results
