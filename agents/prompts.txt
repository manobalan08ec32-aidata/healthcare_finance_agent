async def select_dataset(self, state: AgentState) -> Dict[str, any]:
    """Enhanced dataset selection with complete workflow handling"""
    # Initialize control flow variables
    create_sql = False
    create_sql_after_followup = False
    metadata_result = None
    selected_dataset = None
    selection_reasoning = ''
    functional_names = []
    filter_metadata_results = []  # Initialize to prevent UnboundLocalError
    
    # SQL Generation and Execution Phase
    if create_sql or create_sql_after_followup:
        print(f"üîß Starting SQL generation and execution phase")
        
        # Generate SQL based on the flow type
        if create_sql_after_followup:
            # SQL follow-up flow
            context = self._extract_context(state)
            sql_followup_question = state.get('sql_followup_question', '')
            sql_followup_answer = state.get('current_question', '')
            
            sql_result = await self._generate_sql_with_followup_async(context, sql_followup_question, sql_followup_answer, state)
            
            # ========================================
            # CHECK FOR TOPIC DRIFT OR NEW QUESTION
            # ========================================
            if sql_result.get('topic_drift', False):
                print("‚ö†Ô∏è Topic drift detected - user response unrelated to follow-up question")
                return {
                    'success': False,
                    'sql_followup_topic_drift': True,
                    'sql_followup_but_new_question': False,
                    'message': sql_result.get('message', 'Your response seems unrelated to the clarification requested.'),
                    'original_followup_question': sql_result.get('original_followup_question', ''),
                    'selected_dataset': selected_dataset or state.get('selected_dataset', []),
                    'dataset_metadata': state.get('dataset_metadata', '')
                }
            
            if sql_result.get('new_question', False):
                print("‚ö†Ô∏è New question detected - user asked different question instead of answering")
                return {
                    'success': False,
                    'sql_followup_topic_drift': False,
                    'sql_followup_but_new_question': True,
                    'message': sql_result.get('message', "You've asked a new question instead of providing clarification."),
                    'original_followup_question': sql_result.get('original_followup_question', ''),
                    'detected_new_question': sql_result.get('detected_new_question', ''),
                    'selected_dataset': selected_dataset or state.get('selected_dataset', []),
                    'dataset_metadata': state.get('dataset_metadata', '')
                }
            
            print("‚úÖ Follow-up response validated - proceeding with SQL execution")
            
        else:
            # Initial SQL generation flow
            sql_result = await self._assess_and_generate_sql_async(self._extract_context(state), state)
        
        # Handle follow-up questions if needed
        if sql_result.get('needs_followup'):
            return {
                'success': True,
                'needs_followup': True,
                'sql_followup_topic_drift': False,
                'sql_followup_but_new_question': False,
                'sql_followup_question': sql_result['sql_followup_questions'],
                'selected_dataset': selected_dataset or state.get('selected_dataset', []),
                'dataset_metadata': state.get('dataset_metadata', ''),
                'selection_reasoning': selection_reasoning,
                'functional_names': functional_names
            }
        
        if not sql_result['success']:
            return {
                'success': False,
                'sql_followup_topic_drift': False,
                'sql_followup_but_new_question': False,
                'error': sql_result['error'],
                'selected_dataset': selected_dataset or state.get('selected_dataset', []),
                'dataset_metadata': state.get('dataset_metadata', '')
            }
        
        # Execute SQL queries and return results
        context = self._extract_context(state)
        if sql_result.get('multiple_sql', False):
            print(f"  ‚ö° Executing {len(sql_result['sql_queries'])} SQL queries in parallel...")
            final_result = await self._execute_multiple_sql_queries_async(sql_result, context)
        else:
            print(f"  ‚ö° Executing single SQL query...")
            final_result = await self._execute_single_sql_query_async(sql_result, context, create_sql_after_followup)
        
        # Return comprehensive results
        return {
            'sql_result': final_result,
            'sql_followup_topic_drift': False,
            'sql_followup_but_new_question': False,
            'selected_dataset': selected_dataset or state.get('selected_dataset', []),
            'dataset_metadata': state.get('dataset_metadata', ''),
            'dataset_followup_question': None,
            'selection_reasoning': selection_reasoning,
            'functional_names': functional_names,
            'requires_clarification': False,
            'filter_metadata_results': filter_metadata_results
        }
    
    # Should not reach here, but handle gracefully
    return {
        'error': True,
        'error_message': "Unexpected flow in dataset selection"
    }
