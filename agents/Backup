async def search_column_values(
        self,
        search_terms: List[str],
        max_columns: int = 7,
        max_values_per_column: int = 5
    ) -> List[str]:
        """
        Search column values directly from Delta table.
        
        Tier Priority (for sorting, not exclusion):
            Tier 1: Exact match
            Tier 2: Prefix match
            Tier 3: Contains ALL words
            Tier 4: Contains SOME words
        
        Shows all matches, sorted by tier. No exclusion.
        """
        
        if not search_terms:
            return []
        
        # Build search phrases
        search_phrases = []
        all_words = set()
        
        for term in search_terms:
            term_lower = term.strip().lower()
            if term_lower:
                words = [w for w in term_lower.split() if len(w) > 2]
                search_phrases.append({
                    "phrase": term_lower,
                    "words": words,
                    "is_multi_word": len(words) > 1
                })
                all_words.update(words)
                all_words.add(term_lower)
        
        if not search_phrases:
            return []
        
        print(f"üîç Search phrases: {[sp['phrase'] for sp in search_phrases]}")
        
        # Escape single quotes for SQL
        def escape_sql(val):
            return val.replace("'", "''")
        
        # Build exact match conditions
        exact_phrases = [f"'{escape_sql(sp['phrase'])}'" for sp in search_phrases]
        exact_list = ", ".join(exact_phrases)
        
        # Build prefix match conditions
        prefix_conditions = [f"value_lower LIKE '{escape_sql(sp['phrase'])}%'" for sp in search_phrases]
        prefix_clause = " OR ".join(prefix_conditions)
        
        # Build contains conditions (for any word)
        contains_conditions = [f"value_lower LIKE '%{escape_sql(w)}%'" for w in all_words]
        contains_clause = " OR ".join(contains_conditions)
        
        # Single query - get ALL matches with tier
        query = f"""
        SELECT 
            column_name,
            value_lower,
            CASE 
                WHEN value_lower IN ({exact_list}) THEN 1
                WHEN {prefix_clause} THEN 2
                ELSE 3
            END as tier
        FROM prd_optumrx_orxfdmprdsa.rag.column_values_index
        WHERE value_lower IN ({exact_list})
           OR ({prefix_clause})
           OR ({contains_clause})
        ORDER BY column_name, tier, value_lower
        """
        
        print(f"üîç Executing search query...")
        
        try:
            # Execute query
            result_data = await self.execute_sql_async_audit(query)
            
            # Convert to list
            if hasattr(result_data, 'collect'):
                rows = [row.asDict() for row in result_data.collect()]
            elif isinstance(result_data, list):
                rows = result_data
            else:
                print(f"‚ùå Unexpected result type: {type(result_data)}")
                return []
            
            if not rows:
                print("‚ùå No matches found")
                return []
            
            print(f"‚úÖ Found {len(rows)} total matches")
            
            # Apply Tier 3 vs 4 logic for multi-word searches
            has_multi_word = any(sp["is_multi_word"] for sp in search_phrases)
            
            if has_multi_word:
                rows = self._assign_tier_3_4(rows, search_phrases)
            
            # Group by column with tier info
            # Structure: {column_name: {"best_tier": int, "values": [(value, tier), ...]}}
            column_data = {}
            
            for row in rows:
                col = row["column_name"]
                val = row["value_lower"]
                tier = row["tier"]
                
                if col not in column_data:
                    column_data[col] = {"best_tier": tier, "values": []}
                
                # Update best tier for column
                if tier < column_data[col]["best_tier"]:
                    column_data[col]["best_tier"] = tier
                
                # Add value if not duplicate
                existing_values = [v[0] for v in column_data[col]["values"]]
                if val not in existing_values:
                    column_data[col]["values"].append((val, tier))
            
            # Sort columns by best tier, then by column name
            sorted_columns = sorted(
                column_data.items(),
                key=lambda x: (x[1]["best_tier"], x[0])
            )
            
            # Format output
            results = []
            for col_name, col_info in sorted_columns[:max_columns]:
                # Sort values by tier, then alphabetically
                sorted_values = sorted(col_info["values"], key=lambda x: (x[0], x[1]))
                
                # Take top N values
                top_values = [v[0] for v in sorted_values[:max_values_per_column]]
                values_str = ", ".join(top_values)
                
                results.append(f"{col_name} - {values_str}")
                print(f"   Tier {col_info['best_tier']}: {col_name} ‚Üí {top_values}")
            
            print(f"‚úÖ Search complete: {len(results)} columns")
            return results
            
        except Exception as e:
            print(f"‚ùå Error in search_column_values: {str(e)}")
            return []
    

    def _assign_tier_3_4(
            self, 
            rows: List[dict], 
            search_phrases: List[dict]
        ) -> List[dict]:
        """
        For Tier 3 results from SQL, reassign to Tier 3 (ALL words) or Tier 4 (SOME words).
        """
        
        updated_rows = []
        
        for row in rows:
            value = row["value_lower"]
            current_tier = row["tier"]
            
            # Only process Tier 3 (contains matches)
            if current_tier != 3:
                updated_rows.append(row)
                continue
            
            # Check against multi-word phrases
            new_tier = 4  # Default to SOME words
            
            for sp in search_phrases:
                phrase = sp["phrase"]
                words = sp["words"]
                is_multi_word = sp["is_multi_word"]
                
                if not is_multi_word:
                    # Single word - if it's in value, it's Tier 3
                    if phrase in value:
                        new_tier = 3
                        break
                else:
                    # Multi-word - check if ALL words present
                    words_found = [w for w in words if w in value]
                    
                    if len(words_found) == len(words):
                        new_tier = 3
                        break
            
            row["tier"] = new_tier
            updated_rows.append(row)
        
        return updated_rows
```

---

## Summary

| Aspect | Behavior |
|--------|----------|
| Tier exclusion | None - show all |
| Column sorting | By best tier in column |
| Value sorting | By tier, then alphabetically |
| Max columns | 7 |
| Max values per column | 5 |
| Multi-word logic | Tier 3 (ALL words) vs Tier 4 (SOME words) |

---

## Expected Output

**Search:** `["egwp"]`
```
account_id - egwp, egwp_corp, egwp_123
orcl_prod_desc - egwp fee, egwp admin fee
blng_entty_cd - egwps041, egwps042
