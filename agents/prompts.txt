async def _generate_sql_with_followup_async(self, context: Dict, sql_followup_question: str, sql_followup_answer: str, state: Dict) -> Dict[str, Any]:
    """Generate SQL using original question + follow-up Q&A with relevance validation in single call"""
    
    current_question = context.get('current_question', '')
    dataset_metadata = context.get('dataset_metadata', '')
    join_clause = state.get('join_clause', '')
    selected_filter_context = context.get('selected_filter_context')
    if state.get('requires_dataset_clarification', False):
        followup_reasoning = state.get('followup_reasoning', '')
    else:
        followup_reasoning = state.get('selection_reasoning','')
    
    # Check if we have multiple tables
    selected_datasets = state.get('selected_dataset', [])
    
    # Define mandatory column mapping
    mandatory_column_mapping = {
        "prd_optumrx_orxfdmprdsa.rag.ledger_actual_vs_forecast": [
            "Ledger"
        ]
    }
    
    # Extract mandatory columns based on selected datasets
    mandatory_columns_info = []
    if isinstance(selected_datasets, list):
        for dataset in selected_datasets:
            if dataset in mandatory_column_mapping:
                mandatory_columns = mandatory_column_mapping[dataset]
                for col in mandatory_columns:
                    mandatory_columns_info.append(f"Table {dataset}: {col} (MANDATORY)")
            else:
                mandatory_columns_info.append(f"Table {dataset}: Not Applicable")
    
    # Format mandatory columns for prompt
    mandatory_columns_text = "\n".join(mandatory_columns_info) if mandatory_columns_info else "Not Applicable"
    
    # Format selected filter context for prompt
    filter_context_text = ""
    if selected_filter_context:
        filter_context_text = f"""
SELECTED FILTER CONTEXT Available for SQL generation if the filter values exactly matches:
    final selection : {selected_filter_context}
"""
    
    has_multiple_tables = len(selected_datasets) > 1 if isinstance(selected_datasets, list) else False

    followup_sql_prompt = f"""
You are a highly skilled Healthcare Finance SQL analyst. This is PHASE 2 of a two-phase process.

ORIGINAL USER QUESTION: {current_question}
**AVAILABLE METADATA**: {dataset_metadata}
MULTIPLE TABLES AVAILABLE: {has_multiple_tables}
JOIN INFORMATION: {join_clause if join_clause else "No join clause provided"}
MANDATORY FILTER COLUMNS: {mandatory_columns_text}

FILTER VALUES EXTRACTED:
{filter_context_text}

==============================
STEP 1: VALIDATE FOLLOW-UP RESPONSE
==============================

YOUR PREVIOUS QUESTION: {sql_followup_question}
USER'S RESPONSE: {sql_followup_answer}

**FIRST, analyze if the user's response is relevant:**

1. **RELEVANT**: User directly answered or provided clarification ‚Üí PROCEED to SQL generation
2. **NEW_QUESTION**: User asked a completely new question instead of answering ‚Üí STOP, return new_question flag
3. **TOPIC_DRIFT**: User's response is completely unrelated/off-topic ‚Üí STOP, return topic_drift flag

**If NOT RELEVANT (categories 2 or 3), immediately return the appropriate XML response below and STOP.**
**If RELEVANT (category 1), proceed to STEP 2 for SQL generation.**

==============================
STEP 2: SQL GENERATION (Only if RELEVANT)
==============================

Generate a high-quality Databricks SQL query using:
1. The ORIGINAL user question as the primary requirement
2. The USER'S CLARIFICATION to resolve any ambiguities
3. Available metadata for column mapping
4. Multi-table strategy assessment (single vs multiple queries)
5. All SQL generation best practices

**MULTI-QUERY DECISION LOGIC**:
- **SINGLE QUERY WITH JOIN**: Simple analysis requiring related data from multiple tables
- **MULTIPLE QUERIES - MULTI-TABLE**: Complementary analysis from different tables OR no join exists
- **MULTIPLE QUERIES - COMPLEX SINGLE-TABLE**: Multiple analytical dimensions (trends + rankings)
- **SINGLE QUERY**: Simple, focused questions with one analytical dimension

========================================
CRITICAL DATABRICKS SQL GENERATION RULES
=========================================

<<<<<leaving it blank>>>>

==============================
OUTPUT FORMATS
==============================

**OPTION 1: If user's response is a NEW QUESTION**
<new_question>
<detected>true</detected>
<reasoning>[Brief 1-sentence why this is a new question]</reasoning>
</new_question>

**OPTION 2: If user's response is TOPIC DRIFT (unrelated)**
<topic_drift>
<detected>true</detected>
<reasoning>[Brief 1-sentence why this is off-topic]</reasoning>
</topic_drift>

**OPTION 3: If RELEVANT - Single SQL Query**
<sql>
[Your complete SQL query incorporating both original question and clarifications]
</sql>

**OPTION 4: If RELEVANT - Multiple SQL Queries**
<multiple_sql>
<query1_title>[Brief descriptive title - max 8 words]</query1_title>
<query1>[First SQL query]</query1>
<query2_title>[Brief descriptive title - max 8 words]</query2_title>
<query2>[Second SQL query]</query2>
</multiple_sql>

Return ONLY ONE of the above XML formats based on your analysis.
"""

    for attempt in range(self.max_retries):
        try:
            llm_response = await self.db_client.call_claude_api_endpoint_async([
                {"role": "user", "content": followup_sql_prompt}
            ])

            # Check for new_question flag first
            new_question_match = re.search(r'<new_question>.*?<detected>(.*?)</detected>.*?<reasoning>(.*?)</reasoning>.*?</new_question>', llm_response, re.DOTALL)
            if new_question_match:
                detected = new_question_match.group(1).strip().lower() == 'true'
                reasoning = new_question_match.group(2).strip()
                if detected:
                    return {
                        'success': False,
                        'topic_drift': False,
                        'new_question': True,
                        'message': f"You've asked a new question instead of providing clarification. {reasoning}",
                        'original_followup_question': sql_followup_question,
                        'detected_new_question': sql_followup_answer
                    }

            # Check for topic_drift flag
            topic_drift_match = re.search(r'<topic_drift>.*?<detected>(.*?)</detected>.*?<reasoning>(.*?)</reasoning>.*?</topic_drift>', llm_response, re.DOTALL)
            if topic_drift_match:
                detected = topic_drift_match.group(1).strip().lower() == 'true'
                reasoning = topic_drift_match.group(2).strip()
                if detected:
                    return {
                        'success': False,
                        'topic_drift': True,
                        'new_question': False,
                        'message': f"Your response seems unrelated to the clarification requested. {reasoning}",
                        'original_followup_question': sql_followup_question
                    }

            # Check for multiple SQL queries
            multiple_sql_match = re.search(r'<multiple_sql>(.*?)</multiple_sql>', llm_response, re.DOTALL)
            if multiple_sql_match:
                multiple_content = multiple_sql_match.group(1).strip()
                
                # Extract individual queries with titles
                query_matches = re.findall(r'<query(\d+)_title>(.*?)</query\1_title>.*?<query\1>(.*?)</query\1>', multiple_content, re.DOTALL)
                if query_matches:
                    sql_queries = []
                    query_titles = []
                    for i, (query_num, title, query) in enumerate(query_matches):
                        cleaned_query = query.strip().replace('`', '')
                        cleaned_title = title.strip()
                        if cleaned_query and cleaned_title:
                            sql_queries.append(cleaned_query)
                            query_titles.append(cleaned_title)
                    
                    if sql_queries:
                        return {
                            'success': True,
                            'multiple_sql': True,
                            'topic_drift': False,
                            'new_question': False,
                            'sql_queries': sql_queries,
                            'query_titles': query_titles,
                            'query_count': len(sql_queries)
                        }
                
                raise ValueError("Empty or invalid multiple SQL queries in XML response")
            
            # Check for single SQL query
            match = re.search(r'<sql>(.*?)</sql>', llm_response, re.DOTALL)
            if match:
                sql_query = match.group(1).strip()
                sql_query = sql_query.replace('`', '')  # Remove backticks
                
                if not sql_query:
                    raise ValueError("Empty SQL query in XML response")
                
                return {
                    'success': True,
                    'multiple_sql': False,
                    'topic_drift': False,
                    'new_question': False,
                    'sql_query': sql_query
                }
            else:
                raise ValueError("No valid XML response found (expected sql, multiple_sql, new_question, or topic_drift)")
        
        except Exception as e:
            print(f"‚ùå SQL generation with follow-up attempt {attempt + 1} failed: {str(e)}")
            
            if attempt < self.max_retries - 1:
                print(f"üîÑ Retrying SQL generation with follow-up... (Attempt {attempt + 1}/{self.max_retries})")
                await asyncio.sleep(2 ** attempt)
    
    return {
        'success': False,
        'topic_drift': False,
        'new_question': False,
        'error': f"SQL generation with follow-up failed after {self.max_retries} attempts due to Model errors"
    }
