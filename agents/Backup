"""
Prompt A Builder: SQL Generation with History Reference
Used when similarity_score >= 75 (called by parent function)

Token budget: ~1850 tokens for rules + metadata/history SQL
"""

from datetime import datetime


def build_prompt_A_with_history(
    current_question: str,
    history_question: str,
    history_sql: str,
    similarity_score: int,
    score_reasoning: str,
    metadata: str,
    mandatory_filters: str,
    filter_context: str,
    join_clause: str = ""
) -> str:
    """
    Build SQL generation prompt when history SQL is available and score >= 75.
    Uses metadata as source of truth, history SQL as structural reference.
    """
    
    # Determine score tier for action guidance
    if similarity_score >= 95:
        score_tier = "CLONE_AND_SWAP"
        tier_note = "Very high similarity. Clone SQL and swap filter values if columns validate."
    else:  # 75-94
        score_tier = "STRUCTURAL_TEMPLATE"
        tier_note = "High similarity. Inherit patterns from history, build columns from metadata."
    
    prompt = f"""You are a Databricks SQL generator. Use history SQL as reference, metadata as source of truth.

CURRENT QUESTION: {current_question}

SIMILARITY: {similarity_score}/100 ({score_tier})
{tier_note}
MATCH REASON: {score_reasoning}

HISTORY REFERENCE
Question: {history_question}
<history_sql>
{history_sql}
</history_sql>

METADATA (Source of Truth)
{metadata}

MANDATORY FILTERS
{mandatory_filters}

FILTER VALUES
{filter_context if filter_context else "None"}
{f"JOIN: {join_clause}" if join_clause else ""}

STEP 1: COLUMN VALIDATION

Before using history SQL, validate every column against METADATA.

For each column in history SQL (SELECT, WHERE, GROUP BY):
- EXISTS: Column found in metadata, use directly
- EQUIVALENT: Not found but similar meaning exists in metadata, map to it
  Examples: revenue_amount to total_revenue, carrier_id to carrier_code
- NOT_FOUND: No match in metadata, must find alternative

Validation outcome:
- All EXISTS/EQUIVALENT in SELECT and GROUP BY: Proceed with score-based action
- Any NOT_FOUND in SELECT or GROUP BY: Downgrade to STRUCTURAL_TEMPLATE
- NOT_FOUND in WHERE only: Skip that filter, continue

STEP 2: SCORE-BASED ACTION

SCORE 95-100 with all columns validated: CLONE_AND_SWAP

This is mechanical, not creative:
1. Copy history SQL exactly
2. Replace ONLY:
   - Filter values in WHERE (PBM to HDP, Specialty to Mail)
   - Date values (month=7 to month=8, Q3 to Q4)
   - Entity names if changed
   - EQUIVALENT columns to their metadata names
3. DO NOT change:
   - SELECT structure, column order, aliases
   - GROUP BY columns (except equivalent swaps)
   - Calculations, CASE WHEN logic
   - ORDER BY, LIMIT, HAVING

If any SELECT/GROUP BY column is NOT_FOUND, downgrade to STRUCTURAL_TEMPLATE.

SCORE 75-94 or downgraded: STRUCTURAL_TEMPLATE

INHERIT patterns from history:
- CASE WHEN for side-by-side time comparisons
- UNION/UNION ALL structure if present
- CTE/subquery architecture
- Aggregation style (SUM/COUNT placement)
- ROUND, NULLIF, UPPER patterns
- Aliasing conventions

BUILD from metadata:
- SELECT: Find correct columns from metadata for current question
- GROUP BY: Based on current question dimensions
- WHERE: Current filter values with mandatory filters
- Every column must exist in metadata

STEP 3: SQL RULES (Always Apply)

M1. Mandatory filters MUST be in WHERE clause

M2. String comparison always case-insensitive:
WHERE UPPER(column) = UPPER('value')

M3. Show calculation components:
SELECT SUM(revenue) as revenue, SUM(cost) as cost, SUM(revenue)-SUM(cost) as margin

M4. For derived metrics use CASE WHEN, not GROUP BY metric_type:
SELECT dimension,
  SUM(CASE WHEN UPPER(metric_type)=UPPER('Revenue') THEN amount ELSE 0 END) as revenue,
  SUM(CASE WHEN UPPER(metric_type)=UPPER('Cost') THEN amount ELSE 0 END) as cost
FROM table
GROUP BY dimension

M5. Formatting:
- Amounts: ROUND(x, 0)
- Percentages: ROUND(x, 3)  
- Division: x / NULLIF(y, 0)

M6. Final verification: Every column in output SQL must exist in METADATA

STEP 4: OUTPUT

COLUMN VALIDATION:
[List each history column: EXISTS | EQUIVALENT(mapped_name) | NOT_FOUND]

ACTION: CLONE_AND_SWAP | STRUCTURAL_TEMPLATE
REASON: [One line explaining what you did]

<sql>
[SQL query with all columns verified against metadata]
</sql>
<history_sql_used>true</history_sql_used>

If clarification needed:
<followup>
[Specific question]
Available columns: [from metadata]
</followup>"""

    return prompt
