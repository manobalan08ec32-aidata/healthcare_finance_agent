-- Drop if exists
DROP TABLE IF EXISTS prd_optumrx_orxfdmprdsa.rag.column_values_index;

-- Create pre-exploded index table
CREATE TABLE prd_optumrx_orxfdmprdsa.rag.column_values_index AS
SELECT 
    column_name,
    LOWER(TRIM(value)) as value_lower
FROM prd_optumrx_orxfdmprdsa.rag.distinct_values_metadata1
LATERAL VIEW EXPLODE(SPLIT(distinct_values, ',')) AS value
WHERE TRIM(value) IS NOT NULL 
  AND TRIM(value) != '';

-- Optimize for search performance
OPTIMIZE prd_optumrx_orxfdmprdsa.rag.column_values_index ZORDER BY (column_name, value_lower);

-- Verify
SELECT column_name, COUNT(*) as value_count 
FROM prd_optumrx_orxfdmprdsa.rag.column_values_index 
GROUP BY column_name 
ORDER BY value_count DESC;

-- Run daily to refresh index
TRUNCATE TABLE prd_optumrx_orxfdmprdsa.rag.column_values_index;

INSERT INTO prd_optumrx_orxfdmprdsa.rag.column_values_index
SELECT 
    column_name,
    LOWER(TRIM(value)) as value_lower
FROM prd_optumrx_orxfdmprdsa.rag.distinct_values_metadata1
LATERAL VIEW EXPLODE(SPLIT(distinct_values, ',')) AS value
WHERE TRIM(value) IS NOT NULL 
  AND TRIM(value) != '';

OPTIMIZE prd_optumrx_orxfdmprdsa.rag.column_values_index ZORDER BY (column_name, value_lower);


async def search_column_values(
        self,
        search_terms: List[str],
        max_columns: int = 7,
        max_values_per_column: int = 5
    ) -> List[str]:
        """
        Search column values directly from Delta table with exclusive tier logic.
        
        Tier Priority (Exclusive):
            Tier 1: Exact match
            Tier 2: Prefix match
            Tier 3: Contains ALL words
            Tier 4: Contains SOME words (fallback)
        """
        
        if not search_terms:
            return []
        
        # Build search phrases
        search_phrases = []
        all_words = set()
        
        for term in search_terms:
            term_lower = term.strip().lower()
            if term_lower:
                words = [w for w in term_lower.split() if len(w) > 2]
                search_phrases.append({
                    "phrase": term_lower,
                    "words": words,
                    "is_multi_word": len(words) > 1
                })
                all_words.update(words)
                all_words.add(term_lower)  # Add full phrase too
        
        if not search_phrases:
            return []
        
        print(f"üîç Search phrases: {[sp['phrase'] for sp in search_phrases]}")
        
        # Escape single quotes for SQL
        def escape_sql(val):
            return val.replace("'", "''")
        
        # Build exact match conditions
        exact_phrases = [f"'{escape_sql(sp['phrase'])}'" for sp in search_phrases]
        exact_list = ", ".join(exact_phrases)
        
        # Build prefix match conditions
        prefix_conditions = [f"value_lower LIKE '{escape_sql(sp['phrase'])}%'" for sp in search_phrases]
        prefix_clause = " OR ".join(prefix_conditions)
        
        # Build contains conditions (for any word)
        contains_conditions = [f"value_lower LIKE '%{escape_sql(w)}%'" for w in all_words]
        contains_clause = " OR ".join(contains_conditions)
        
        # Single query with tier assignment
        query = f"""
        WITH matched_values AS (
            SELECT 
                column_name,
                value_lower,
                CASE 
                    WHEN value_lower IN ({exact_list}) THEN 1
                    WHEN {prefix_clause} THEN 2
                    ELSE 3
                END as tier
            FROM prd_optumrx_orxfdmprdsa.rag.column_values_index
            WHERE value_lower IN ({exact_list})
               OR {prefix_clause}
               OR ({contains_clause})
        ),
        best_tier AS (
            SELECT MIN(tier) as min_tier FROM matched_values
        )
        SELECT 
            m.column_name,
            m.value_lower,
            m.tier
        FROM matched_values m
        CROSS JOIN best_tier b
        WHERE m.tier = b.min_tier
        ORDER BY m.column_name, m.value_lower
        """
        
        print(f"üîç Executing search query...")
        
        try:
            # Execute query using your existing async method
            result_data = await self.execute_sql_async_audit(query)
            
            # Convert to list
            if hasattr(result_data, 'collect'):
                rows = [row.asDict() for row in result_data.collect()]
            elif isinstance(result_data, list):
                rows = result_data
            else:
                print(f"‚ùå Unexpected result type: {type(result_data)}")
                return []
            
            if not rows:
                print("‚ùå No matches found")
                return []
            
            best_tier = rows[0]["tier"]
            print(f"‚úÖ Found {len(rows)} matches at Tier {best_tier}")
            
            # For Tier 3, filter: ALL words vs SOME words
            if best_tier == 3:
                rows = self._apply_tier_3_4_logic(rows, search_phrases)
                
                if not rows:
                    print("‚ùå No matches after Tier 3/4 filtering")
                    return []
            
            # Group by column
            column_values = {}
            for row in rows:
                col = row["column_name"]
                val = row["value_lower"]
                
                if col not in column_values:
                    column_values[col] = []
                
                if val not in column_values[col] and len(column_values[col]) < max_values_per_column:
                    column_values[col].append(val)
            
            # Format output
            results = []
            sorted_columns = sorted(column_values.items())[:max_columns]
            
            for col_name, values in sorted_columns:
                values_str = ", ".join(values)
                results.append(f"{col_name} - {values_str}")
                print(f"   {col_name} ‚Üí {values}")
            
            print(f"‚úÖ Search complete: {len(results)} columns")
            return results
            
        except Exception as e:
            print(f"‚ùå Error in search_column_values: {str(e)}")
            return []
    

    def _apply_tier_3_4_logic(
            self, 
            rows: List[dict], 
            search_phrases: List[dict]
        ) -> List[dict]:
        """
        For Tier 3 SQL results, apply exclusive ALL vs SOME words logic.
        
        - Tier 3: Value contains ALL words from phrase
        - Tier 4: Value contains SOME words from phrase
        
        Returns only Tier 3 if exists, else Tier 4.
        """
        
        tier_3_rows = []  # Contains ALL words
        tier_4_rows = []  # Contains SOME words
        
        for row in rows:
            value = row["value_lower"]
            is_tier_3 = False
            is_tier_4 = False
            
            for sp in search_phrases:
                phrase = sp["phrase"]
                words = sp["words"]
                is_multi_word = sp["is_multi_word"]
                
                if not is_multi_word:
                    # Single word phrase - if value contains it, it's Tier 3
                    if phrase in value:
                        is_tier_3 = True
                        break
                else:
                    # Multi-word phrase - check how many words match
                    words_found = [w for w in words if w in value]
                    
                    if len(words_found) == len(words):
                        # ALL words found
                        is_tier_3 = True
                        break
                    elif len(words_found) > 0:
                        # SOME words found
                        is_tier_4 = True
            
            if is_tier_3:
                tier_3_rows.append(row)
            elif is_tier_4:
                tier_4_rows.append(row)
        
        # Return Tier 3 if exists, else Tier 4 (exclusive)
        if tier_3_rows:
            print(f"   Tier 3 (ALL words): {len(tier_3_rows)} matches")
            return tier_3_rows
        
        print(f"   Tier 4 (SOME words): {len(tier_4_rows)} matches")
        return tier_4_rows
