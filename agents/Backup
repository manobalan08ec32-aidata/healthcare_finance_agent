STAGE 4: HISTORICAL SQL PATTERN MATCHING

PURPOSE: Historical SQL represents LEARNED DETAIL PREFERENCES. Your goal is to ENHANCE simple questions with historical detail patterns - not just copy SQL.
PRINCIPLE: If history shows breakdown + totals for a dimension, provide that detail level even if user asks a simple question.
Never mention history to user.

IF NO HISTORICAL SQL AVAILABLE:
- Skip this stage
- Generate SQL fresh in Stage 5
- Set history_sql_used = false

IF HISTORICAL SQL IS AVAILABLE:

STEP 4.1: SEMANTIC COMPARISON
Compare current question vs historical question:

A. SAME METRIC REQUESTED?
   Current asks for: [identify metric]
   Historical had: [identify metric]
   Match: YES / NO

B. SAME GROUPING DIMENSIONS?
   Current groups by: [identify dimensions]
   Historical grouped by: [identify dimensions]
   Match: YES / NO

C. SAME ANALYSIS TYPE?
   Types: breakdown | top-N | comparison | trend | calculation
   Current: [type]
   Historical: [type]
   Match: YES / NO

STEP 4.2: PATTERN DECISION MATRIX

IF Metric=YES AND Grouping=YES AND Type=YES:
  -> FULL PATTERN REUSE
  -> Copy entire SQL structure
  -> Replace ONLY filter values (dates, entities) with current values
  -> Set history_sql_used = true

IF Metric=YES AND (Grouping=NO OR Type=NO):
  -> PARTIAL PATTERN REUSE + DETAIL ENHANCEMENT
  -> Keep: Metric calculations, CASE WHEN patterns, aggregation methods, OVERALL TOTALS
  -> CRITICAL - BREAKDOWN INHERITANCE:
     If history breaks down by sub-dimension (e.g., product_sub_category_lvl_2)
     AND current question filters on parent (e.g., product_category='Home Delivery')
     AND user did NOT say "total only" / "just sum" / "aggregate"
     → INCLUDE the sub-breakdown with OVERALL_TOTAL row
     → This ENHANCES a simple question with useful detail
  -> Set history_sql_used = true

IF Metric=NO:
  -> STRUCTURAL LEARNING ONLY
  -> Learn: UNION patterns, CTE structure, NULLIF safety, ROUND formatting, OVERALL TOTALS
  -> Build: Fresh SQL for current question using these techniques
  -> Set history_sql_used = false

STEP 4.3: DETECT AND REPLICATE HISTORY PATTERN

Identify pattern in HISTORICAL SQL, then REPLICATE structure exactly:

PATTERN A - GROUPING_SETS_TOTAL (history has "GROUPING SETS" + "GROUPING("):
  Your SQL MUST include:
  - CASE WHEN GROUPING(breakdown_col) = 1 THEN 'OVERALL_TOTAL' ELSE breakdown_col END
  - GROUP BY GROUPING SETS ((all_dims), (all_dims minus breakdown_col))
  - ORDER BY ... CASE WHEN breakdown_col = 'OVERALL_TOTAL' THEN 0 ELSE 1 END
  
  WHEN TO APPLY (any of these):
  - User explicitly asks for breakdown
  - History has breakdown on sub-dimension + current filters parent dimension + same metric
  - User asks comparison across time periods
  
  ONLY SKIP WHEN: User explicitly says "total only", "just the sum", "single number"

PATTERN B - UNION_TOTAL (history has "UNION ALL" + 'Total'/'OVERALL' literal):
  Your SQL MUST include: Detail query UNION ALL total query with 'OVERALL_TOTAL' literal
  
  WHEN TO APPLY: Same conditions as Pattern A

PATTERN C - SIMPLE (neither above):
  No total row required

ALWAYS LEARN from history: CASE WHEN for side-by-side columns, NULLIF(denominator, 0), ROUND formatting, UPPER() comparisons
NEVER COPY from history: Filter values (dates, entities), time periods, <parameter> placeholders

CRITICAL: Pattern structure is MANDATORY when conditions met. Only replace filter values with current question's values.
Log: history_pattern = GROUPING_SETS_TOTAL | UNION_TOTAL | SIMPLE | NONE

VALIDATION: Every column in final SQL must exist in CURRENT metadata - history may reference columns not in current dataset.


history_section= f"""
HISTORICAL SQL REFERENCE (Internal Use Only - Do NOT mention to user)
PREVIOUS QUESTION: {history_question_match}
TABLE: {matched_table_name}

<historical_sql>
{matched_sql}
</historical_sql>

PURPOSE: History represents LEARNED DETAIL PREFERENCES. When history shows breakdowns/totals, ENHANCE current response with same detail level even if user's question is simple.
    """
