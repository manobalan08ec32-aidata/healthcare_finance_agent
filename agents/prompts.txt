async def search_column_values(
        self,
        search_terms: List[str],
        column_index: Dict[str, Any],
        max_columns: int = 7,
        max_values_per_column: int = 5
    ) -> List[str]:
        """
        Search for values across columns with exclusive tier matching.
        
        Tier Priority (Exclusive - stops at first tier found):
            Tier 1: Exact match (value == search term)
            Tier 2: Prefix match (value starts with search term)
            Tier 3: Contains ALL words (for multi-word search)
            Tier 4: Contains SOME words (fallback)
        
        If Tier N matches exist, Tier N+1 and below are ignored completely.
        """
        
        if not search_terms:
            return []
        
        columns_data = column_index.get("columns", {})
        
        if not columns_data:
            print("‚ö†Ô∏è No columns data found in column index")
            return []
        
        # Build search list
        search_phrases = []
        
        for term in search_terms:
            term_lower = term.strip().lower()
            if term_lower:
                words = term_lower.split()
                search_phrases.append({
                    "phrase": term_lower,
                    "words": [w for w in words if len(w) > 2],
                    "is_multi_word": len(words) > 1
                })
        
        print(f"üîç Search phrases: {[s['phrase'] for s in search_phrases]}")
        
        # Collect matches by tier
        # Structure: {tier: {column_name: [values]}}
        tier_matches = {1: {}, 2: {}, 3: {}, 4: {}}
        
        for col_name, values in columns_data.items():
            
            for value in values:
                
                for search_item in search_phrases:
                    phrase = search_item["phrase"]
                    words = search_item["words"]
                    is_multi_word = search_item["is_multi_word"]
                    
                    tier = None
                    
                    # TIER 1: Exact match
                    if value == phrase:
                        tier = 1
                    
                    # TIER 2: Prefix match
                    elif value.startswith(phrase):
                        tier = 2
                    
                    # TIER 3 & 4: Contains logic
                    elif is_multi_word:
                        words_found = [w for w in words if w in value]
                        
                        if len(words_found) == len(words):
                            # All words found
                            tier = 3
                        elif len(words_found) > 0:
                            # Some words found
                            tier = 4
                    
                    else:
                        # Single word contains
                        if phrase in value:
                            tier = 3
                    
                    # Record match
                    if tier is not None:
                        if col_name not in tier_matches[tier]:
                            tier_matches[tier][col_name] = []
                        
                        if value not in tier_matches[tier][col_name]:
                            tier_matches[tier][col_name].append(value)
                        
                        break  # One match per value is enough
        
        # Find best tier that has matches (exclusive selection)
        best_tier = None
        for tier in [1, 2, 3, 4]:
            if tier_matches[tier]:
                best_tier = tier
                break
        
        if best_tier is None:
            print("‚ùå No matches found")
            return []
        
        print(f"‚úÖ Best tier: {best_tier}")
        
        # Get only the best tier results
        selected_matches = tier_matches[best_tier]
        
        # Sort columns alphabetically
        sorted_columns = sorted(selected_matches.items(), key=lambda x: x[0])
        
        # Format output
        results = []
        for col_name, matched_values in sorted_columns[:max_columns]:
            # Sort values and take top N
            sorted_values = sorted(matched_values)[:max_values_per_column]
            values_str = ", ".join(sorted_values)
            
            results.append(f"{col_name} - {values_str}")
            print(f"   {col_name} ‚Üí {sorted_values}")
        
        print(f"‚úÖ Search complete: Tier {best_tier}, {len(results)} columns")
        return results
